4월의 낙원호 회고
===

4월의 낙원호는 지인이 운영한 역할극입니다. 역할극은 30여 명의 고정된 인원이 10일 동안 진행하였는데요. 참가자들이 역할극을 즐기는 동안 이용할 수 있는 환경과, 참가자를 관리할 수 있는 백오피스를 만드는 것이 주목표였습니다.

- 개발: 2024년 3월 5일 ~ 서비스 종료까지
- 서비스: 2024년 4월 13일 ~ 22일 (10일)
- 기술 스택: SvelteKit(Svelte 5), EdgeDB 4, Docker, Sentry

https://github.com/tnraro/blog/assets/8617317/dac2054b-b5e5-4ce6-b097-d886970b44c0

![Arc_C7vfwXYpLu](https://github.com/tnraro/blog/assets/8617317/48841b1c-1446-4f88-b968-f7d040e3b0d6)

## 협업

역할극 위원회가 따로 있고, 그중 한 분이 제게 아웃소싱을 주셔서 작업하게 되었습니다. 리소스를 제공해 주시고 같이 고민해 주시는 등 각종 편의를 봐주셔서 덕분에 개발에만 집중할 수 있었습니다. 작업의 형태 특성상 모두와 소통할 수 없었던 건 단점이었습니다. 전달받은 사양에서 의도를 끄집어내서 요구사항을 분석하고 확인하는 과정이 필요했습니다. 소규모 팀의 장점인 모두와 긴밀하게 협업하기를 시도해 봤으면 좋았겠다 싶은 아쉬움이 남습니다.

## SVG 애니메이션

낙원호에는 미니 게임이 있고, 미니 게임에는 애니메이션이 빠질 수 없는데요. 어떻게 하면 애니메이션을 효과적으로 구현할 수 있을까 고민했습니다. 

가장 먼저 시도한 방법은 SVG를 직접 다루는 것이었습니다. 평소 디자인 툴을 사용할 때 '이 부분은 자동으로 처리가 되면 좋겠다.' 싶은 부분이 종종 있었는데요. 처음부터 코드로 작성하면 이런 문제가 해결됩니다. Svelte 컴포넌트 덕분에 스타일, 애니메이션, 로직을 원하는 정도로 작성할 수도 있었고요. 물론 디자인을 직접해서 가능했던 면도 있는 것 같습니다.

그 뒤에 Rive 같은 상태를 가지는 애니메이션 툴을 사용해 교차 검증을 해봤는데요. 역시나 협업이 가능하다는 점을 제외하고는 직접 작성하는 편이 중복도 적고, 자유도도 높아서 계속 SVG를 사용하기로 했습니다.

## 왜 EdgeDB?

처음 백엔드를 구상할 때 데이터를 저장하기 위해 굳이 RDBMS를 써야 할지 고민했습니다. 빠르게 프로토타입을 만들 수 있는 NoSQL을 먼저 고려했습니다. 이전에 좋은 경험이 있던 Redis를 먼저 조사했는데요. 만에 하나 서버에 문제가 생겼을 경우 가능성은 작지만, 복구가 불가능할 수 있어서 제외하기로 했습니다. 이후, 한 스타트업에서 EdgeDB에 비즈니스 로직을 둬서 빠르게 제작할 수 있었다는 글을 읽었는데요. 도입하게 된 계기와 고민 과정이 현 상황에 알맞아서 홀리듯 EdgeDB를 선택하게 되었습니다.

## 백오피스

백오피스는 4명의 관리자가 다룰 예정이었습니다. 따라서 동시 편집 기능이 필요하다고 생각되었는데요. 직접 구현하는 것보다 잘 만든 CRDT 라이브러리를 사용하기로 했습니다. Y.js와 Liveblocks를 고려했는데요. 특히 Liveblocks는 프로젝트 규모상 완전히 무료로 쓸 수 있어서 즉시 써보기로 했습니다. 하지만, Liveblocks 클라이언트 기능이 생각보다 부족했습니다. 결국 비용을 따져 봤을 때 구글 스프레드시트보다 나은 점이 없어서 스프레드시트 API로 동기화하기로 했습니다.

## EdgeDB 쿼리 43배 빠르게 만들기

개발 환경에서 API 호출이 평균 537ms가 걸렸는데요. N100이 들어있는 실 서버에서는 2,322ms가 걸렸습니다. 설상가상으로 트랜잭션이 쌓이면서 5,000ms를 넘고, 트랜잭션이 실패하기 시작했습니다. 첫날에 Sentry에 보고된 같은 오류만 23건이 생겼습니다.

첫날에는 원인 규명을 위한 시간을 벌기 위해 클라이언트의 오류 핸들링에 신경을 쓰고, 애니메이션 딜레이를 수동으로 늘렸습니다. 그리고 본격적으로 느린 끝점을 디버깅했습니다.

디버깅 한 결과 인증에 사용하는 `global ext::auth::ClientTokenIdentity`가 정말 느렸는데요. 이게 global 때문에 모든 쿼리에서 사용되고 있었습니다. 여기에 Access Policy, Trigger을 걸어놔서 쿼리 한 번에 `global ext::auth::ClientTokenIdentity`가 2~3번 이상 쿼리 되고 있었습니다.

결국 API 요청마다 단 한 번만 `global ext::auth::ClientTokenIdentity`을 쿼리하고 이를 재사용하도록 변경했습니다.

```diff
+ global currentUserId -> uuid;
  global currentUser := (
    assert_single((
      select User
-     filter .identity = global ext::auth::ClientTokenIdentity
+     filter .id = global currentUserId
    ))
  );
```

이 덕분에 2,322ms가 걸리던 요청이 54ms로 대폭 줄었습니다.